/*
 * 问题：编写一个函数setbits，该函数返回对x执行下列操作后的结果值：将 x中从第p位开始的n个（二进制）位设置为y中最右边n位的值，x的其余各位保持不变
 *
 * 分析：看到这个问题，我真心没头绪，后面拿着笔画了一下，思路清晰多了。
 * 注意：p是从0开始，由右往左
 * 假设x=10100110,y=10010011,p=3,n=2.我们得到的结果应该是：10101110
 * 首先我们需要将x中的移动位变成0，然后将y中的非移动位变成0，接着把y的移动位移动到与x位对应，最后x与y进行'或'运算得到最后结果
 * 即x=10100110 => 10100010,y=10010011 => 00000011 => 00001100
 * 最后10100010 | 00001100 = 10101110
 */
#include <stdio.h>
int main(void)
{
	int x = 166, //10100110
		y = 147, //10010011
		p = 3, n = 2;
	printf("%d\n", setbits(x,p, n, y ));
	return 0;
}

int setbits(int x, int p, int n , int y)
{
	int tempx, tempy;
	//第一大步变化x，将移动的n位替换成0
	tempx = ~0;		//构造一个全1...1
	tempx = tempx << n;	//左移n位，右边补0，得到1...10...0
	tempx = ~tempx;		//求反得到,0...01...1
	tempx = tempx << (p+1-n);	//左移到p的位置，得到0...01...10...0
	tempx = ~tempx;		//求反，得到最终的1...10...01...1,用于将x的移动位替换成0
	x = x & tempx;		//'与'运算，将x的其他位保持不变，移动位变成0
	printf("%d\n", x);
	//第二大步变化y，将y的非移动位变成0
	tempy = ~0;
	tempy = tempy << n;
	tempy = ~tempy;	//得到0..01..1
	y = y & tempy;	//将y的非移动位替换成0，移动位保持不变，得到0...0y...y
	y = y << (p+1-n);	//需要将y的移动位，移动到对应x中的位置
	return x | y;		//x与y 求'或'，进行替换

}
